<html><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><title>Algebird</title><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="description" content="Abstract Algebra for Scala." /><meta name="author" content="Algebird's contributors" /><meta name="og:image" content="/algebird/img/poster.png" /><meta name="og:title" content="Algebird" /><meta name="og:site_name" content="Algebird" /><meta name="og:url" content="http://twitter.github.io/algebird" /><meta name="og:type" content="website" /><meta name="og:description" content="Abstract Algebra for Scala." /><meta name="twitter:image" content="/algebird/img/poster.png" /><meta name="twitter:card" content="summary_large_image" /><meta name="twitter:site" content="" /><link rel="icon" type="image/png" href="/algebird/img/favicon.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/algebird/highlight/styles/atom-one-light.css" /><link rel="stylesheet" href="/algebird/css/style.css" /><link rel="stylesheet" href="/algebird/css/palette.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/algebird/" class="brand"><div class="brand-wrapper" style="background:url('/algebird/img/sidebar_brand.png') no-repeat"><span>Algebird</span></div></a></li> <li><a href="/algebird/datatypes.html" class="">Data Types</a></li> <li><a href="/algebird/datatypes/combinator.html" class="">Combinators</a> <ul class="sub_section"> <li><a href="/algebird/datatypes/combinator/collections.html" class="">Scala Collections</a></li> <li><a href="/algebird/datatypes/combinator/java_collections.html" class="">Java Collections</a></li> <li><a href="/algebird/datatypes/combinator/option_monoid.html" class="">Option Monoid</a></li> <li><a href="/algebird/datatypes/combinator/caseclass.html" class="">Case Class Algebra</a></li> <li><a href="/algebird/datatypes/combinator/cuber.html" class="">Cuber</a></li> <li><a href="/algebird/datatypes/combinator/roller.html" class="">Roller</a></li> <li><a href="/algebird/datatypes/combinator/eventually.html" class="">Eventually</a></li> <li><a href="/algebird/datatypes/combinator/priority.html" class="">Priority</a></li> <li><a href="/algebird/datatypes/combinator/product_algebra.html" class="">Product/Tuple Algebra</a></li> <li><a href="/algebird/datatypes/combinator/monoid_statistics.html" class="">Monoid Statistics</a></li></ul></li> <li><a href="/algebird/datatypes/approx.html" class="">Approximate Data Types</a> <ul class="sub_section"> <li><a href="/algebird/datatypes/approx/approximate.html" class="">Approximate</a></li> <li><a href="/algebird/datatypes/approx/bloom_filter.html" class="">Bloom Filter</a></li> <li><a href="/algebird/datatypes/approx/countminsketch.html" class="">Count Min Sketch</a></li> <li><a href="/algebird/datatypes/approx/exponential_histogram.html" class=" active ">Exponential Histogram</a></li> <li><a href="/algebird/datatypes/approx/hyperloglog.html" class="">HyperLogLog</a></li> <li><a href="/algebird/datatypes/approx/hyperloglog_series.html" class="">HyperLogLog Series</a></li> <li><a href="/algebird/datatypes/approx/min_hasher.html" class="">MinHasher</a></li> <li><a href="/algebird/datatypes/approx/q_tree.html" class="">Q Tree</a></li> <li><a href="/algebird/datatypes/approx/space_saver.html" class="">SpaceSaver</a></li></ul></li> <li><a href="/algebird/datatypes/summer.html" class="">Summers</a> <ul class="sub_section"> <li><a href="/algebird/datatypes/summer/adaptive_cache.html" class="">AdaptiveCache</a></li> <li><a href="/algebird/datatypes/summer/batched.html" class="">Batched</a></li> <li><a href="/algebird/datatypes/summer/sum_all.html" class="">SumAll</a></li> <li><a href="/algebird/datatypes/summer/summingcache.html" class="">SummingCache</a></li> <li><a href="/algebird/datatypes/summer/summingiterator.html" class="">SummingIterator</a></li> <li><a href="/algebird/datatypes/summer/summingqueue.html" class="">SummingQueue</a></li></ul></li> <li><a href="/algebird/datatypes/min_and_max.html" class="">Ordered Semigroups</a> <ul class="sub_section"> <li><a href="/algebird/datatypes/first_and_last.html" class="">First and Last</a></li> <li><a href="/algebird/datatypes/min_and_max.html" class="">Min and Max</a></li></ul></li> <li><a href="/algebird/datatypes/adaptive_matrix.html" class="">Adaptive Matrix</a></li> <li><a href="/algebird/datatypes/adaptive_vector.html" class="">Adaptive Vector</a></li> <li><a href="/algebird/datatypes/affine_function.html" class="">Affine Function</a></li> <li><a href="/algebird/datatypes/averaged_value.html" class="">Averaged Value</a></li> <li><a href="/algebird/datatypes/bytes.html" class="">Bytes</a></li> <li><a href="/algebird/datatypes/decayed_value.html" class="">Decayed Value</a></li> <li><a href="/algebird/datatypes/decayed_vector.html" class="">Decayed Vector</a></li> <li><a href="/algebird/datatypes/five_moments.html" class="">First Five Moments</a></li> <li><a href="/algebird/datatypes/gaussian_distribution.html" class="">Gaussian Distribution</a></li> <li><a href="/algebird/datatypes/interval.html" class="">Interval</a></li> <li><a href="/algebird/datatypes/min_plus_algebra.html" class="">Min Plus Algebra</a></li> <li><a href="/algebird/datatypes/reset_state.html" class="">ResetState</a></li> <li><a href="/algebird/datatypes/right_folded.html" class="">RightFolded</a></li> <li><a href="/algebird/datatypes/set_diff.html" class="">SetDiff</a></li> <li><a href="/algebird/datatypes/sgd.html" class="">Stochastic Gradient Descent</a></li> <li><a href="/algebird/datatypes/topk.html" class="">TopK</a></li>         </ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li class="hidden-xs"><a href="https://github.com/twitter/algebird"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li class="hidden-xs"><a href="https://github.com/twitter/algebird"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('Algebird Abstract Algebra for Scala.');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('Algebird Abstract Algebra for Scala.');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="twitter" data-github-repo="algebird"><div class="content-wrapper"><section><h1 id="exponential-histogram">Exponential Histogram</h1>

<p>The <code class="highlighter-rouge">ExpHist</code> data structure implements the Exponential Histogram algorithm from <a href="http://www-cs-students.stanford.edu/~datar/papers/sicomp_streams.pdf">Maintaining Stream Statistics over Sliding Windows</a>, by Datar, Gionis, Indyk and Motwani.</p>

<p>An Exponential Histogram is a sliding window counter that can guarantee a bounded relative error. You configure the data structure with</p>

<ul>
  <li><code class="highlighter-rouge">epsilon</code>, the relative error you’re willing to tolerate</li>
  <li><code class="highlighter-rouge">windowSize</code>, the number of time ticks that you want to track</li>
</ul>

<p>You interact with the data structure by adding (number, timestamp) pairs into the exponential histogram. querying it for an approximate counts with <code class="highlighter-rouge">guess</code>.</p>

<p>The approximate count is guaranteed to be within <code class="highlighter-rouge">conf.epsilon</code> relative error of the true count seen across the supplied <code class="highlighter-rouge">windowSize</code>.</p>

<h2 id="example-usage">Example Usage</h2>

<p>Let’s set up a bunch of buckets to add into our exponential histogram. Each bucket tracks a delta and a timestamp. This example uses the same number for both, for simplicity.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">com.twitter.algebird.ExpHist</span>
<span class="c1">// import com.twitter.algebird.ExpHist
</span>
<span class="k">import</span> <span class="nn">ExpHist.</span><span class="o">{</span> <span class="nc">Bucket</span><span class="o">,</span> <span class="nc">Config</span><span class="o">,</span> <span class="nc">Timestamp</span> <span class="o">}</span>
<span class="c1">// import ExpHist.{Bucket, Config, Timestamp}
</span>
<span class="k">val</span> <span class="n">maxTimestamp</span> <span class="k">=</span> <span class="mi">200</span>
<span class="c1">// maxTimestamp: Int = 200
</span>
<span class="k">val</span> <span class="n">inputs</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="n">maxTimestamp</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span>
    <span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">ExpHist</span><span class="o">.</span><span class="nc">Bucket</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="nc">Timestamp</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
  <span class="o">}.</span><span class="n">toVector</span>
<span class="c1">// inputs: Vector[com.twitter.algebird.ExpHist.Bucket] = Vector(Bucket(1,Timestamp(1)), Bucket(2,Timestamp(2)), Bucket(3,Timestamp(3)), Bucket(4,Timestamp(4)), Bucket(5,Timestamp(5)), Bucket(6,Timestamp(6)), Bucket(7,Timestamp(7)), Bucket(8,Timestamp(8)), Bucket(9,Timestamp(9)), Bucket(10,Timestamp(10)), Bucket(11,Timestamp(11)), Bucket(12,Timestamp(12)), Bucket(13,Timestamp(13)), Bucket(14,Timestamp(14)), Bucket(15,Timestamp(15)), Bucket(16,Timestamp(16)), Bucket(17,Timestamp(17)), Bucket(18,Timestamp(18)), Bucket(19,Timestamp(19)), Bucket(20,Timestamp(20)), Bucket(21,Timestamp(21)), Bucket(22,Timestamp(22)), Bucket(23,Timestamp(23)), Bucket(24,Timestamp(24)), Bucket(25,Timestamp(25)), Bucket(26,Timestamp(26)), Bucket(27,Timestamp(27)), Bucket(28,Timestamp(28)), Bucket(29,Timestamp(29)), ...
</span>
<span class="k">val</span> <span class="n">actualSum</span> <span class="k">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">size</span><span class="o">).</span><span class="n">sum</span>
<span class="c1">// actualSum: Long = 20100
</span></code></pre>
</div>

<p>Now we’ll configure an instance of <code class="highlighter-rouge">ExpHist</code> to track the count and add each of our buckets in.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">epsilon</span> <span class="k">=</span> <span class="mf">0.01</span>
<span class="c1">// epsilon: Double = 0.01
</span>
<span class="k">val</span> <span class="n">windowSize</span> <span class="k">=</span> <span class="n">maxTimestamp</span>
<span class="c1">// windowSize: Int = 200
</span>
<span class="k">val</span> <span class="n">eh</span> <span class="k">=</span> <span class="nc">ExpHist</span><span class="o">.</span><span class="n">empty</span><span class="o">(</span><span class="nc">Config</span><span class="o">(</span><span class="n">epsilon</span><span class="o">,</span> <span class="n">windowSize</span><span class="o">))</span>
<span class="c1">// eh: com.twitter.algebird.ExpHist = ExpHist(Config(0.01,200),Vector(),0,Timestamp(0))
</span>
<span class="k">val</span> <span class="n">full</span> <span class="k">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="n">eh</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">histogram</span><span class="o">,</span> <span class="nc">Bucket</span><span class="o">(</span><span class="n">delta</span><span class="o">,</span> <span class="n">timestamp</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">histogram</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">delta</span><span class="o">,</span> <span class="n">timestamp</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// full: com.twitter.algebird.ExpHist = ExpHist(Config(0.01,200),Vector(Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), Bucket(1,Timestamp(200)), ...
</span></code></pre>
</div>

<p>Now we can query the full exponential histogram and compare the guess to the actual sum:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">approximateSum</span> <span class="k">=</span> <span class="n">full</span><span class="o">.</span><span class="n">guess</span>
<span class="c1">// approximateSum: Double = 19972.5
</span>
<span class="n">full</span><span class="o">.</span><span class="n">relativeError</span>
<span class="c1">// res0: Double = 0.006424792139077854
</span>
<span class="k">val</span> <span class="n">maxError</span> <span class="k">=</span> <span class="n">actualSum</span> <span class="o">*</span> <span class="n">full</span><span class="o">.</span><span class="n">relativeError</span>
<span class="c1">// maxError: Double = 129.13832199546485
</span>
<span class="n">assert</span><span class="o">(</span><span class="n">full</span><span class="o">.</span><span class="n">guess</span> <span class="o">&lt;=</span> <span class="n">actualSum</span> <span class="o">+</span> <span class="n">maxError</span><span class="o">)</span>

<span class="n">assert</span><span class="o">(</span><span class="n">full</span><span class="o">.</span><span class="n">guess</span> <span class="o">&gt;=</span> <span class="n">actualSum</span> <span class="o">-</span> <span class="n">maxError</span><span class="o">)</span>
</code></pre>
</div>

<h2 id="l-canonical-representation">l-Canonical Representation</h2>

<p>The exponential histogram algorithm tracks buckets of size <code class="highlighter-rouge">2^i</code>. Every new increment to the histogram adds a bucket of size 1.</p>

<p>Because only <code class="highlighter-rouge">l</code> or <code class="highlighter-rouge">l+1</code> buckets of size <code class="highlighter-rouge">2^i</code> are allowed for each <code class="highlighter-rouge">i</code>, this increment might trigger an incremental merge of smaller buckets into larger buckets.</p>

<p>Let’s look at 10 steps of the algorithm with <code class="highlighter-rouge">l == 2</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>1:  1 (1 added)
2:  1 1 (1 added)
3:  1 1 1 (1 added)
4:  1 1 2 (1 added, triggering a 1 + 1 = 2 merge)
5:  1 1 1 2 (1 added)
6:  1 1 2 2 (1 added, triggering a 1 + 1 = 2 merge)
7:  1 1 1 2 2 (1 added)
8:  1 1 2 2 2 (1 added, triggering a 1 + 1 = 2 merge AND a 2 + 2 = 4 merge)
9:  1 1 1 2 2 2 (1 added)
10: 1 1 2 2 4 (1 added, triggering a 1 + 1 = 2 merge AND a 2 + 2 = 4 merge)
</code></pre>
</div>

<p>Notice that the bucket sizes always sum to the algorithm step, ie <code class="highlighter-rouge">10 == 1 + 1 + 1 + 2 + 2 + 4</code>.</p>

<p>Now let’s write out a list of the number of buckets of each size, ie <code class="highlighter-rouge">[bucketsOfSize(1), bucketsOfSize(2), bucketsOfSize(4), ....]</code>. Here’s the above sequence in the new representation, plus a few more steps:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>1:  1     &lt;-- (l + 1)2^0 - l = 3 * 2^0 - 2 = 1
2:  2
3:  3
4:  2 1   &lt;-- (l + 1)2^1 - l = 3 * 2^0 - 2 = 4
5:  3 1
6:  2 2
7:  3 2
8:  2 3
9:  3 3
10: 2 2 1 &lt;-- (l + 1)2^2 - l = 3 * 2^0 - 2 = 10
11: 3 2 1
12: 2 3 1
13: 3 3 1
14: 2 2 2
15: 3 2 2
16: 2 3 2
16: 3 3 2
17: 2 2 3
</code></pre>
</div>

<p>This sequence is called the “l-canonical representation” of <code class="highlighter-rouge">s</code>.</p>

<p>A pattern emerges! Every bucket size except the largest looks like a binary counter (if you added <code class="highlighter-rouge">l + 1</code> to the bit, and made the counter little-endian). Let’s call this the “binary” prefix, or <code class="highlighter-rouge">bin(_)</code>.</p>

<p>Here’s the above sequence with the prefix decoded from “binary”:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>1:  1        &lt;-- (l + 1)2^0 - l = 3 * 2^0 - 2 = 1
2:  2
3:  3

4:  bin(0) 1 &lt;-- (l + 1)2^1 - l = 3 * 2^0 - 2 = 4
5:  bin(1) 1
6:  bin(0) 2
7:  bin(1) 2
8:  bin(0) 3
9:  bin(1) 3

10: bin(0) 1 &lt;-- (l + 1)2^2 - l = 3 * 2^0 - 2 = 10
11: bin(1) 1
12: bin(2) 1
13: bin(3) 1
14: bin(0) 2
15: bin(1) 2
16: bin(2) 2
16: bin(3) 2
17: bin(0) 3
</code></pre>
</div>

<p>Some observations about the pattern:</p>

<p>The l-canonical representation groups the natural numbers into groups of size <code class="highlighter-rouge">(l + 1)2^i</code> for <code class="highlighter-rouge">i &gt;= 0</code>.</p>

<p>Each group starts at <code class="highlighter-rouge">(l + 1)2^i - l</code> (see 1, 4, 10… above)</p>

<p>Within each group, the “binary” prefix of the l-canonical rep cycles from <code class="highlighter-rouge">0</code> to <code class="highlighter-rouge">(2^i - 1)</code>, <code class="highlighter-rouge">l + 1</code> total times. (This makes sense; each cycle increments the final entry by one until it hits <code class="highlighter-rouge">l + 1</code>; after that an increment triggers a merge and a new “group” begins.)</p>

<p>The final l-canonical entry == <code class="highlighter-rouge">floor((position within the group) / 2^i)</code>, or the “quotient” of that position and <code class="highlighter-rouge">2^i</code>.</p>

<p>That’s all we need to know to write a procedure to generate the l-canonical representation! Here it is again:</p>

<h2 id="l-canonical-representation-procedure">L-Canonical Representation Procedure</h2>

<ul>
  <li>Find the largest <code class="highlighter-rouge">j</code> s.t. <code class="highlighter-rouge">2^j &lt;= (s + l) / (1 + l)</code></li>
  <li>let <code class="highlighter-rouge">s' := 2^j(1 + l) - l</code></li>
</ul>

<p>(<code class="highlighter-rouge">s'</code> is the position if the start of a group, ie 1, 4, 10…)</p>

<ul>
  <li><code class="highlighter-rouge"><span class="gh">diff := (s - s')</span></code> is the position of s within that group.</li>
  <li>let <code class="highlighter-rouge">b :=</code> the little-endian binary rep of <code class="highlighter-rouge"><span class="gh">diff % (2^j - 1)</span></code></li>
  <li>let <code class="highlighter-rouge">ret :=</code> return vector of length <code class="highlighter-rouge">j</code>:</li>
</ul>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">j</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span> <span class="n">i</span> <span class="k">=&gt;</span> <span class="n">ret</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="k">=</span> <span class="n">b</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">+</span> <span class="n">l</span> <span class="o">}</span>
<span class="n">ret</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="k">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="o">(</span><span class="n">diff</span> <span class="o">/</span> <span class="mi">2</span><span class="o">^</span><span class="n">j</span><span class="o">)</span>
</code></pre>
</div>
</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/algebird/highlight/highlight.pack.js"></script><script>hljs.configure({
languages:['scala','java','bash']
});
hljs.initHighlighting();
             </script><script src="/algebird/js/main.js"></script></body></html>